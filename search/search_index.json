{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome! This wiki has many tutorials and resources related to making scalable web systems. </p> <p>On the left is our navigation section that helps you find the content you need. </p> <p>If you need help finding something, use the search functionality!</p>"},{"location":"0-kubernetes/kubernetes-basics/","title":"Kubernetes basics","text":""},{"location":"0-kubernetes/kubernetes-basics/#kubernetes-basics","title":"kubernetes-basics","text":"<p>Docker</p> <p></p>"},{"location":"0-kubernetes/kubernetes-basics/#introduction","title":"Introduction","text":"<p>Kubernetes (K8s in short) is an open-source container orchestration platform introduced by Google in 2014. The platform\u2019s main purpose is to automate deployment and management (e.g., update, scaling, security, networking, auto-repair) of containerized application in large distributed computer clusters. To this end, the platform offers a number of API primitives, deployment options, networking, container and storage interfaces, built-in security, and other useful features. </p>"},{"location":"0-kubernetes/kubernetes-basics/#author","title":"Author","text":"<p>Abhinav Tripathy</p>"},{"location":"0-kubernetes/kubernetes-basics/#high-level-concepts","title":"High Level Concepts","text":""},{"location":"0-kubernetes/kubernetes-basics/#pods","title":"Pods","text":"<p>Pods are the smallest unit in kubernetes. Pods represent containers that are actually running.</p>"},{"location":"0-kubernetes/kubernetes-basics/#nodes","title":"Nodes","text":"<p>A collection of pods represent a node. Nodes are often a physical machine that are actually running the pods. </p>"},{"location":"0-kubernetes/kubernetes-basics/#clusters","title":"Clusters","text":"<p>A collection of nodes represent a cluster. Clusters are by geographic region, which is where all the compute resources are hosted in the cloud. </p> <p></p>"},{"location":"0-kubernetes/kubernetes-basics/#notes","title":"Notes","text":"<p>Often when working with kubernetes one does not really create the individual pods and by defauly they don't really have an external IP. As a devops engineer, one would define number of pods required and then for the node have a load balancer than balances traffic between the pods and the load balancer creates a static IP that one uses to access the service. </p>"},{"location":"0-kubernetes/kubernetes-basics/#key-benefits","title":"Key Benefits","text":""},{"location":"0-kubernetes/kubernetes-basics/#focus-on-configuration","title":"Focus on Configuration","text":"<p>The main benefit of kubernetes is that it allows you to use a yaml file to define the desired state of the application and kubernetes as a system and engine will make sure that that state is always ensured. This allows for less work and hassle for devops engineers is as self managed as possible. As part of configuration, one can define how many replica of pods one wants, these could be defined as minimum and maximum or an exact number. Further, one can define compute resources to be dedicated to the pod creation, exact memory and CPU allocation can be specified for the pods. One can be conservative in terms of resource allocation to save on costs, it all depends on how one defines the system requirements to kubernetes. </p>"},{"location":"0-kubernetes/kubernetes-basics/#auto-repair","title":"Auto Repair","text":"<p>Auto repair is a key feature in kubernetes. For example, if we want 2 pods always running on the minimum for an application and all of a sudden one pod goes down due to high memory usage/CPU usage, kubernetes will either restart or recreate the pod which will be specifically useful. This goes back to show how devops engineers need to focus on config and kubernetes will take care of the rest. </p>"},{"location":"0-kubernetes/kubernetes-basics/#auto-scaling","title":"Auto Scaling","text":"<p>Kuberenetes is also really good for scaling and especially autoscaling. It can scale from 3 requests per second to 3 million requests per second very easily. It has autoscaling features that can be enabled from one command. For the use case of CYE, this might be useful if there is unexpected traffic, it can scale and create additional pods or even nodes if required. </p>"},{"location":"0-kubernetes/kubernetes-basics/#acknowledgements","title":"Acknowledgements","text":""},{"location":"0-kubernetes/kubernetes-basics/#feedback","title":"Feedback","text":"<p>If you have any feedback or comments or want to improve something, please open an issue on github here</p>"},{"location":"0-kubernetes/kubernetes-system-design/","title":"Kubernetes system design","text":""},{"location":"0-kubernetes/kubernetes-system-design/#kubernetes-system-design","title":"Kubernetes-System-Design","text":""},{"location":"0-kubernetes/kubernetes-system-design/#author","title":"Author","text":"<p>Abhinav Tripathy Linkedin</p>"},{"location":"0-kubernetes/kubernetes-system-design/#introduction","title":"Introduction","text":"<p>When it comes to building scalable systems, kubernetes is a great tool and a quite a popular one. However, there are many fundamental concepts that one needs to think about from a system design perspective when thinking about scalable systems in the context of kubernetes. This tutorial hopes to cover some of the fundamental concepts such as databases, caching, the CAP theorem. </p>"},{"location":"0-kubernetes/kubernetes-system-design/#the-cap-theorem","title":"The CAP Theorem","text":"<p>CAP stands for:</p> <pre><code>CAP: Consistency, Availability, Partition Tolerance\n</code></pre> <p>Let us define these terms: - Consistency: any read operation that begins after a write operation completes must return that value, or the result of a later write operation - Availability: every request received by a non-failing node in the system must result in a response - Partition Tolerance: the network will be allowed to lose arbitrarily many messages sent from one node to another</p> <p>The theorem:</p> <pre><code>The CAP theorem states that a distributed system cannot simultaneously be consistent, available, and partition tolerant. \n</code></pre> <p>An illustrated proof of the theorem. </p> <p>An Example: </p> <p>In order to get both availability and partition tolerance, you have to give up consistency. Consider if you have two nodes, X and Y. Now, there is a break between network communication between X and Y, so they can't sync updates. At this point you can either:</p> <p>A) Allow the nodes to get out of sync (giving up consistency), or</p> <p>B) Consider the cluster to be \"down\" (giving up availability)</p> <p>The different combinations in CAP:</p> <ul> <li>CA - data is consistent between all nodes - as long as all nodes are online - and you can read/write from any node and be sure that the data is the same, but if you ever develop a partition between nodes, the data will be out of sync (and won't re-sync once the partition is resolved).</li> <li>CP - data is consistent between all nodes, and maintains partition tolerance (preventing data desync) by becoming unavailable when a node goes down.</li> <li>AP - nodes remain online even if they can't communicate with each other and will resync data once the partition is resolved, but you aren't guaranteed that all nodes will have the same data (either during or after the partition)</li> </ul> <p>An image displaying the proof:</p> <p></p> <p>Important Note: CAP is a spectrum. What that means is that it is not a hard and fast rule that only 2 out of the 3 will work but rather it is a theorem to think about tradeoffs. Certain transactions require high availability some require high consistency. It helps a system designer to think about trade offs, optimize for these 3 important constraints. </p>"},{"location":"0-kubernetes/kubernetes-system-design/#single-point-of-failure-spof","title":"Single Point of Failure (SPOF)","text":"<p>In any scalable system, we must avoid single point of failures. As the name suggests, it is a a node,(it could be any part of the system) if it fails the whole system would go down. </p> <p>As an example, this image displays how a single load balancer could be an SPOF. </p> <p></p> <p>As the image suggests, having multiple load balancers is the solution. </p> <p>To mitigate SPOFs we have 3 key approaches:</p> <ul> <li>More Nodes: With more nodes one can duplicate the node or service and distribute traffic among them. Another way is to use the secondary node/nodes as a backup service, though that would potentially lead to wasting resources. </li> <li>Master Slave Approach: This approach is quite useful especially in the context of databases. The main question here is what if a database goes down. This can be mitigated by having a master database off which slaves replicate. So in the case master goes down, one of the slaves can become a master. There can be additional complexity such as having multiple masters or having read only slaves/write only slaves. </li> <li>Master - Master Approach: This is like the master slave approach however in this case the two or more nodes, all get read requests and write loads are distributed among the master nodes. The advantage it is a simple automatic failover. The main disadvatange is that it is loosely consistent and it is not as simple as master-slave to configure. </li> <li>Multiple Regions: Having all resources in one region can also mean a SPOF. For instance, all your services in the cloud are in the US east region. To avoid, infrastructure going down in one area or a natural disaster happenning, having services and resources split across multiple regions is a good practice.</li> </ul> <p>An Example Diagram of master slave approach:</p> <p></p>"},{"location":"0-kubernetes/kubernetes-system-design/#databases","title":"Databases","text":"<p>The following are some key concepts in databases. </p>"},{"location":"0-kubernetes/kubernetes-system-design/#acid-compliance","title":"ACID Compliance","text":"<p>Atomicity: Database transactions, like atoms, can be broken  down into smaller parts. When it comes to your database, atomicity  refers to the integrity of the entire database transaction, not just a  component of it. In other words, if one part of a transaction doesn\u2019t  work like it\u2019s supposed to, the other will fail as a result\u2014and vice  versa. For example, if you\u2019re shopping on an e-commerce site, you must  have an item in your cart in order to pay for it. What you can\u2019t do is  pay for something that\u2019s not in your cart. (You can add something into  your cart and not pay for it, but that database transaction won\u2019t be  complete, and thus not \u2018atomic\u2019, until you pay for it).</p> <p>Consistency: For any database to operate as it\u2019s intended to  operate, it must follow the appropriate data validation rules. Thus,  consistency means that only data which follows those rules is permitted  to be written to the database. If a transaction occurs and results in  data that does not follow the rules of the database, it will be \u2018rolled  back\u2019 to a previous iteration of itself (or \u2018state\u2019) which complies with  the rules. On the other hand, following a successful transaction, new  data will be added to the database and the resulting state will be  consistent with existing rules.</p> <p>Isolation: It\u2019s safe to say that at any given time on Amazon,  there is far more than one transaction occurring on the platform. In  fact, an incredibly huge amount of database transactions are occurring  simultaneously. For a database, isolation refers to the ability to  concurrently process multiple transactions in a way that one does not  affect another. So, imagine you and your neighbor are both trying to buy  something from the same e-commerce platform at the same time. There are  10 items for sale: your neighbor wants five and you want six. Isolation  means that one of those transactions would be completed ahead of the  other one. In other words, if your neighbor clicked first, they will get  five items, and only five items will be remaining in stock. So you will  only get to buy five items. If you clicked first, you will get the six  items you want, and they will only get four. Thus, isolation ensures  that eleven items aren\u2019t sold when only ten exist.</p> <p>Durability: All technology fails from time to time\u2026 the goal  is to make those failures invisible to the end-user. In databases that  possess durability, data is saved once a transaction is completed, even  if a power outage or system failure occurs. Imagine you\u2019re buying  in-demand concert tickets on a site similar to Ticketmaster.com. Right  when tickets go on sale, you\u2019re ready to make a purchase. After being  stuck in the digital waiting room for some time, you\u2019re finally able to  add those tickets to your cart. You then make the purchase and get your  confirmation. However if that database lacks durability, even after your  ticket purchase was confirmed, if the database suffers a failure  incident your transaction would still be lost! As you might expect, this  is a really bad thing to happen for an online e-commerce site, so  transaction durability is a must-have.</p>"},{"location":"0-kubernetes/kubernetes-system-design/#database-sharding","title":"Database Sharding","text":"<p>Database sharding is a popular concept when dealing with high volume data and is a very popular way to manage in No-SQL databases. Shards are autonomous and is an example to scale horizontally. Shards are basically partitions of the database based on a key. This key is what decides the shards, it could be a column value, it could be location or user ID or any other attribute that makes sense and works universally on the incoming data. Each shard can be protected by the master slave architecture for further scalability. </p> <p>An example of shards:</p> <p></p>"},{"location":"0-kubernetes/kubernetes-system-design/#caching","title":"Caching","text":"<p>Caching is a way to speed up retrieval of frequently or commonly accessed data. This means storing data in something like Redis that helps retrieve data very quickly. The reason this is possible is the data is stored in memory instead of a storage device like a disk(which is slower than in memory). In memory storage also means it is volatile which means it does not have ACID compliance. </p>"},{"location":"0-kubernetes/kubernetes-system-design/#advantages-of-caching","title":"Advantages of Caching","text":"<ul> <li>Reduce network calls</li> <li>Reduce Recomputations</li> <li>Reduce Database load</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#caching-policies","title":"Caching Policies","text":"<p>Caching policies are used to delete unnecessary cache values to make sure the cache is up to date and always fresh and relevant to the incoming requests. </p> <ul> <li>LRU Cache - Least Recently Used</li> <li>LFU Cache - Least Frequently Used Cache</li> <li>Sliding window</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#updating-the-cache","title":"Updating the Cache","text":"<ul> <li>Cache Aside</li> <li>Write Through</li> <li>Write Behind</li> <li>Refresh Ahead</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#storing-images","title":"Storing Images","text":""},{"location":"0-kubernetes/kubernetes-system-design/#storing-it-as-a-file-in-a-file-system","title":"Storing it as a file (in a file system)","text":"<ul> <li>Storing files in a file system is often cheaper in the context of cost</li> <li>Database needs to be used to the save the file URL</li> <li>it is a static asset so can be used with CDNs - allows fast access</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#storing-it-in-a-database-as-a-blob","title":"Storing it in a database (as a Blob)","text":"<pre><code>Blob: Binary Large Object\n</code></pre> <ul> <li>Storing the image as a blog in a database means there is ACID compliance which gives transaction garrantuees</li> <li>Indexes with databases can improve search</li> <li>Easy Access control with databases for images is quite useufl too</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#queue-systems","title":"Queue Systems","text":"<p>Queues are used to in many scalable and distributed systems. They allow for asychronous tasks and environment to be handled which allows for better performance. It also makes a scalable system more fault tolerant as it acts as an intermediary between services. They also allow for very high throughput and scalability. </p>"},{"location":"0-kubernetes/kubernetes-system-design/#publisher-subscriber-model","title":"Publisher Subscriber Model","text":"<p>Often queues will be used through a publisher subscriber model. For Example, if we have a pizza delivery system, the client on the front-end acts as a publisher i.e. it publishes orders on to the queue. Then a service that notifies the team aobut the order is a subscriber. There can be mulitple subscribers and producers and a service can act as both. </p> <p>Sample Publisher Subscriber Model: </p> <p>More generall we can say that the model looks like the following: </p>"},{"location":"0-kubernetes/kubernetes-system-design/#message-guarantees","title":"Message Guarantees","text":"<p>In any system, we need to think about potential tradeoffs and guarantees. In queueing systems, one thing to talk about is processing/messaging guarantees. </p> <ul> <li>No guarantee \u2014 No explicit guarantee is provided, so consumers may process messages once, multiple times or never at all.</li> <li>At most once \u2014 This is \u201cbest effort\u201d delivery semantics. Consumers will receive and process messages exactly once or not at all.</li> <li>At least once \u2014 Consumers will receive and process every message, but they may process the same message more than once.</li> <li>Effectively once \u2014 Also contentiously known as exactly once, this promises consumers will process every message once.</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#api-gateway","title":"API Gateway","text":"<p>An API Gateway is the entry door for a client to talk to a collection of backend services. The gateway provides a single entrypoint which allows it to look for the right services to talk to in the backend the return the approporiate result. </p> <p>API Gateway Architecture: </p> <p>Uses for API Gateway: - Rate Limiting - Statistics &amp; User Analytics  - Handling User Authentication  - Handling multiple requests in a microservices architecture </p>"},{"location":"0-kubernetes/kubernetes-system-design/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>CAP</li> <li>Updating cache</li> <li>Message Processing Guarantees</li> </ul>"},{"location":"0-kubernetes/kubernetes-system-design/#feedback","title":"Feedback","text":"<p>If you have any feedback or comments or want to improve something, please open an issue on github here</p>"}]}